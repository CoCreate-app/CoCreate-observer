(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["observer"] = factory();
	else
		root["CoCreate"] = root["CoCreate"] || {}, root["CoCreate"]["observer"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "../CoCreate-components/CoCreate-observer/src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../CoCreate-components/CoCreate-observer/src/index.js":
/*!*************************************************************!*\
  !*** ../CoCreate-components/CoCreate-observer/src/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n// window.addEventListener(\"load\", () => {\n\n/*\nCoCreate.observer.init({ \n\tname: 'CoCreateFetchInit', // no usage, just to provide for console debugging \n\tobserve: ['subtree', 'childList','attributes'], // the same parameters of options in #https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver/observe\n\tattributes: ['data-fetch_collection'], // it doesn't count added nodes or remove nodes\n\tinclude: \".classname\", // a selector to select only elements that matches\n\texclude: \".classname\", // a selector to exclude elements from processing\n\tcallback: function(mutation) { // a function which gets a mutation object according to #https://developer.mozilla.org/en-US/docs/Web/API/MutationRecord\n\t\tCoCreateFetch.initElement(mutation.target)\n\t}\n})\n*/\n\n/**\n * description\n * \n * @param {String} [name] - an optional name to provide for debugging console\n * @param {Array} observe - a list of mutation type to be observerd, a mix of possible `attributes`, `childList` or `subtree`\n * ... and other params can be here \n * \n * @return null\n */\nwindow.counter = 0;\nwindow.counter2 = 0;\n\nif (!Element.prototype.matches) {\n  Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function (s) {\n    var matches = (this.document || this.ownerDocument).querySelectorAll(s),\n        i = matches.length;\n\n    while (--i >= 0 && matches.item(i) !== this) {}\n\n    return i > -1;\n  };\n}\n\nconst CoCreateObserver = {\n  initTasks: new Map(),\n  attrTasks: new Map(),\n  rules: new Map(),\n  rulesArray: [],\n  __init: function () {\n    const self = this;\n    const observer = new MutationObserver((mutationsList, observer) => self.__callback(mutationsList, observer)); // setTimeout(()=>{\n\n    observer.observe(document.body, {\n      attributes: true,\n      childList: true,\n      subtree: true,\n      characterData: false,\n      attributeOldValue: true,\n      characterData: true\n    });\n  },\n  // init: function(data) {\n  //   this.add(data);\n  // },\n  init: function ({\n    observe,\n    include,\n    exclude,\n    attributes,\n    name,\n    callback\n  }) {\n    if (observe.some(x => x == \"childList\")) {\n      this.initTasks.set(callback, {\n        observe,\n        include,\n        exclude,\n        attributes,\n        name\n      });\n    }\n\n    if (observe.some(x => x == \"attributes\")) {\n      this.attrTasks.set(callback, {\n        observe,\n        include,\n        exclude,\n        attributes,\n        name\n      });\n    }\n  },\n  remove: function ({\n    include,\n    exclude,\n    name\n  }) {\n    this.rules.set(name, {\n      include,\n      exclude\n    });\n    this.rulesArray = Array.from(this.rules);\n  },\n  addRule: function ({\n    include,\n    exclude,\n    name\n  }) {\n    this.rules.set(name, {\n      include,\n      exclude\n    });\n    this.rulesArray = Array.from(this.rules);\n  },\n  removeRule: function ({\n    name\n  }) {\n    this.rules.delete(name);\n    this.rulesArray = Array.from(this.rules);\n  },\n  __callback: function (mutationsList, observer) {\n    // console.log(this)\n    for (let mutation of mutationsList) {\n      if (mutation.type == \"childList\" && mutation.addedNodes.length > 0) {\n        //. run init functions\n        this.__initCallback(mutation);\n      }\n\n      if (mutation.type == \"attributes\") {\n        //. run attributes functions\n        this.__attrCallback(mutation);\n      }\n    }\n  },\n  __initCallback: function (mutation) {\n    let addedNodes = Array.from(mutation.addedNodes);\n    this.initTasks.forEach(({\n      observe,\n      include,\n      exclude,\n      attributes,\n      name\n    }, callback) => {\n      mutation.addedNodes.forEach(el => {\n        if (!el.tagName) return;\n\n        if (include && !(el.matches(include) || el.querySelector(include))) {\n          return;\n        }\n\n        if (exclude && (el.matches(exclude) || el.querySelector(exclude))) {\n          return;\n        }\n\n        if (el.created) return;\n        callback.apply(null, [{\n          type: mutation.type,\n          target: el\n        }]);\n      });\n    });\n    addedNodes.map(el => el.created = true);\n  },\n  __attrCallback: function (mutation) {\n    for (let [name, {\n      include,\n      exclude\n    }] of this.rulesArray) {\n      if (include && !mutation.target.matches(include)) return;\n      if (exclude && mutation.target.matches(exclude)) return;\n    }\n\n    this.attrTasks.forEach(({\n      observe,\n      include,\n      exclude,\n      attributes,\n      name\n    }, callback) => {\n      if (attributes && mutation.attributeName && !attributes.includes(mutation.attributeName)) {\n        return;\n      }\n\n      if (include && !mutation.target.matches(include)) return;\n      if (exclude && mutation.target.matches(exclude)) return;\n\n      if (mutation.attributeName) {\n        let newValue = mutation.target.getAttribute(mutation.attributeName);\n\n        if (newValue != mutation.oldValue) {\n          callback.apply(null, [mutation]);\n        }\n      }\n    });\n  },\n  setInitialized: function (element, type) {\n    // element.setAttribute(`initialized_${type}`, \"true\");\n    type = type || \"\";\n    let key = \"co_initialized_\" + type;\n    element[key] = true;\n  },\n  getInitialized: function (element, type) {\n    type = type || \"\";\n    let key = \"co_initialized_\" + type;\n\n    if (!element[key]) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n};\n\nCoCreateObserver.__init();\n\nwindow.CoCreateObserver = CoCreateObserver;\nvar _default = CoCreateObserver;\nexports.default = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5vYnNlcnZlci8uLi9Db0NyZWF0ZS1jb21wb25lbnRzL0NvQ3JlYXRlLW9ic2VydmVyL3NyYy9pbmRleC5qcz8yYjE5Il0sIm5hbWVzIjpbIndpbmRvdyIsImNvdW50ZXIiLCJjb3VudGVyMiIsIkVsZW1lbnQiLCJwcm90b3R5cGUiLCJtYXRjaGVzIiwibWF0Y2hlc1NlbGVjdG9yIiwibW96TWF0Y2hlc1NlbGVjdG9yIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJvTWF0Y2hlc1NlbGVjdG9yIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwicyIsImRvY3VtZW50Iiwib3duZXJEb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJpIiwibGVuZ3RoIiwiaXRlbSIsIkNvQ3JlYXRlT2JzZXJ2ZXIiLCJpbml0VGFza3MiLCJNYXAiLCJhdHRyVGFza3MiLCJydWxlcyIsInJ1bGVzQXJyYXkiLCJfX2luaXQiLCJzZWxmIiwib2JzZXJ2ZXIiLCJNdXRhdGlvbk9ic2VydmVyIiwibXV0YXRpb25zTGlzdCIsIl9fY2FsbGJhY2siLCJvYnNlcnZlIiwiYm9keSIsImF0dHJpYnV0ZXMiLCJjaGlsZExpc3QiLCJzdWJ0cmVlIiwiY2hhcmFjdGVyRGF0YSIsImF0dHJpYnV0ZU9sZFZhbHVlIiwiaW5pdCIsImluY2x1ZGUiLCJleGNsdWRlIiwibmFtZSIsImNhbGxiYWNrIiwic29tZSIsIngiLCJzZXQiLCJyZW1vdmUiLCJBcnJheSIsImZyb20iLCJhZGRSdWxlIiwicmVtb3ZlUnVsZSIsImRlbGV0ZSIsIm11dGF0aW9uIiwidHlwZSIsImFkZGVkTm9kZXMiLCJfX2luaXRDYWxsYmFjayIsIl9fYXR0ckNhbGxiYWNrIiwiZm9yRWFjaCIsImVsIiwidGFnTmFtZSIsInF1ZXJ5U2VsZWN0b3IiLCJjcmVhdGVkIiwiYXBwbHkiLCJ0YXJnZXQiLCJtYXAiLCJhdHRyaWJ1dGVOYW1lIiwiaW5jbHVkZXMiLCJuZXdWYWx1ZSIsImdldEF0dHJpYnV0ZSIsIm9sZFZhbHVlIiwic2V0SW5pdGlhbGl6ZWQiLCJlbGVtZW50Iiwia2V5IiwiZ2V0SW5pdGlhbGl6ZWQiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQUEsTUFBTSxDQUFDQyxPQUFQLEdBQWlCLENBQWpCO0FBQ0FELE1BQU0sQ0FBQ0UsUUFBUCxHQUFrQixDQUFsQjs7QUFDQSxJQUFJLENBQUNDLE9BQU8sQ0FBQ0MsU0FBUixDQUFrQkMsT0FBdkIsRUFBZ0M7QUFDOUJGLFNBQU8sQ0FBQ0MsU0FBUixDQUFrQkMsT0FBbEIsR0FDRUYsT0FBTyxDQUFDQyxTQUFSLENBQWtCRSxlQUFsQixJQUNBSCxPQUFPLENBQUNDLFNBQVIsQ0FBa0JHLGtCQURsQixJQUVBSixPQUFPLENBQUNDLFNBQVIsQ0FBa0JJLGlCQUZsQixJQUdBTCxPQUFPLENBQUNDLFNBQVIsQ0FBa0JLLGdCQUhsQixJQUlBTixPQUFPLENBQUNDLFNBQVIsQ0FBa0JNLHFCQUpsQixJQUtBLFVBQVNDLENBQVQsRUFBWTtBQUNWLFFBQUlOLE9BQU8sR0FBRyxDQUFDLEtBQUtPLFFBQUwsSUFBaUIsS0FBS0MsYUFBdkIsRUFBc0NDLGdCQUF0QyxDQUF1REgsQ0FBdkQsQ0FBZDtBQUFBLFFBQ0VJLENBQUMsR0FBR1YsT0FBTyxDQUFDVyxNQURkOztBQUVBLFdBQU8sRUFBRUQsQ0FBRixJQUFPLENBQVAsSUFBWVYsT0FBTyxDQUFDWSxJQUFSLENBQWFGLENBQWIsTUFBb0IsSUFBdkMsRUFBNkMsQ0FBRTs7QUFDL0MsV0FBT0EsQ0FBQyxHQUFHLENBQUMsQ0FBWjtBQUNELEdBWEg7QUFZRDs7QUFFRCxNQUFNRyxnQkFBZ0IsR0FBRztBQUN2QkMsV0FBUyxFQUFFLElBQUlDLEdBQUosRUFEWTtBQUV2QkMsV0FBUyxFQUFFLElBQUlELEdBQUosRUFGWTtBQUd2QkUsT0FBSyxFQUFFLElBQUlGLEdBQUosRUFIZ0I7QUFJdkJHLFlBQVUsRUFBRSxFQUpXO0FBTXZCQyxRQUFNLEVBQUUsWUFBVztBQUNqQixVQUFNQyxJQUFJLEdBQUcsSUFBYjtBQUNBLFVBQU1DLFFBQVEsR0FBRyxJQUFJQyxnQkFBSixDQUFxQixDQUFDQyxhQUFELEVBQWdCRixRQUFoQixLQUE2QkQsSUFBSSxDQUFDSSxVQUFMLENBQWdCRCxhQUFoQixFQUErQkYsUUFBL0IsQ0FBbEQsQ0FBakIsQ0FGaUIsQ0FJakI7O0FBQ0FBLFlBQVEsQ0FBQ0ksT0FBVCxDQUFpQmxCLFFBQVEsQ0FBQ21CLElBQTFCLEVBQ0U7QUFDRUMsZ0JBQVUsRUFBRSxJQURkO0FBRUVDLGVBQVMsRUFBRSxJQUZiO0FBR0VDLGFBQU8sRUFBRSxJQUhYO0FBSUVDLG1CQUFhLEVBQUUsS0FKakI7QUFLRUMsdUJBQWlCLEVBQUUsSUFMckI7QUFNRUQsbUJBQWEsRUFBRTtBQU5qQixLQURGO0FBVUQsR0FyQnNCO0FBdUJ2QjtBQUNBO0FBQ0E7QUFFQUUsTUFBSSxFQUFFLFVBQVM7QUFBRVAsV0FBRjtBQUFXUSxXQUFYO0FBQW9CQyxXQUFwQjtBQUE2QlAsY0FBN0I7QUFBeUNRLFFBQXpDO0FBQStDQztBQUEvQyxHQUFULEVBQW9FO0FBQ3hFLFFBQUlYLE9BQU8sQ0FBQ1ksSUFBUixDQUFhQyxDQUFDLElBQUlBLENBQUMsSUFBSSxXQUF2QixDQUFKLEVBQXlDO0FBQ3ZDLFdBQUt4QixTQUFMLENBQWV5QixHQUFmLENBQW1CSCxRQUFuQixFQUE2QjtBQUFFWCxlQUFGO0FBQVdRLGVBQVg7QUFBb0JDLGVBQXBCO0FBQTZCUCxrQkFBN0I7QUFBeUNRO0FBQXpDLE9BQTdCO0FBQ0Q7O0FBRUQsUUFBSVYsT0FBTyxDQUFDWSxJQUFSLENBQWFDLENBQUMsSUFBS0EsQ0FBQyxJQUFJLFlBQXhCLENBQUosRUFBMkM7QUFDekMsV0FBS3RCLFNBQUwsQ0FBZXVCLEdBQWYsQ0FBbUJILFFBQW5CLEVBQTZCO0FBQUVYLGVBQUY7QUFBV1EsZUFBWDtBQUFvQkMsZUFBcEI7QUFBNkJQLGtCQUE3QjtBQUF5Q1E7QUFBekMsT0FBN0I7QUFDRDtBQUNGLEdBbkNzQjtBQW9DdkJLLFFBQU0sRUFBRSxVQUFTO0FBQUVQLFdBQUY7QUFBV0MsV0FBWDtBQUFvQkM7QUFBcEIsR0FBVCxFQUFxQztBQUMzQyxTQUFLbEIsS0FBTCxDQUFXc0IsR0FBWCxDQUFlSixJQUFmLEVBQXFCO0FBQUNGLGFBQUQ7QUFBVUM7QUFBVixLQUFyQjtBQUNBLFNBQUtoQixVQUFMLEdBQWtCdUIsS0FBSyxDQUFDQyxJQUFOLENBQVcsS0FBS3pCLEtBQWhCLENBQWxCO0FBQ0QsR0F2Q3NCO0FBeUN2QjBCLFNBQU8sRUFBRSxVQUFTO0FBQUVWLFdBQUY7QUFBV0MsV0FBWDtBQUFvQkM7QUFBcEIsR0FBVCxFQUFxQztBQUM1QyxTQUFLbEIsS0FBTCxDQUFXc0IsR0FBWCxDQUFlSixJQUFmLEVBQXFCO0FBQUNGLGFBQUQ7QUFBVUM7QUFBVixLQUFyQjtBQUNBLFNBQUtoQixVQUFMLEdBQWtCdUIsS0FBSyxDQUFDQyxJQUFOLENBQVcsS0FBS3pCLEtBQWhCLENBQWxCO0FBQ0QsR0E1Q3NCO0FBOEN2QjJCLFlBQVUsRUFBRSxVQUFVO0FBQUNUO0FBQUQsR0FBVixFQUFrQjtBQUM1QixTQUFLbEIsS0FBTCxDQUFXNEIsTUFBWCxDQUFrQlYsSUFBbEI7QUFDQSxTQUFLakIsVUFBTCxHQUFrQnVCLEtBQUssQ0FBQ0MsSUFBTixDQUFXLEtBQUt6QixLQUFoQixDQUFsQjtBQUNELEdBakRzQjtBQW1EdkJPLFlBQVUsRUFBRSxVQUFTRCxhQUFULEVBQXdCRixRQUF4QixFQUFrQztBQUM1QztBQUNBLFNBQUssSUFBSXlCLFFBQVQsSUFBcUJ2QixhQUFyQixFQUFvQztBQUNsQyxVQUFJdUIsUUFBUSxDQUFDQyxJQUFULElBQWlCLFdBQWpCLElBQWdDRCxRQUFRLENBQUNFLFVBQVQsQ0FBb0JyQyxNQUFwQixHQUE2QixDQUFqRSxFQUFvRTtBQUNsRTtBQUNBLGFBQUtzQyxjQUFMLENBQW9CSCxRQUFwQjtBQUNEOztBQUVELFVBQUlBLFFBQVEsQ0FBQ0MsSUFBVCxJQUFpQixZQUFyQixFQUFtQztBQUNqQztBQUNBLGFBQUtHLGNBQUwsQ0FBb0JKLFFBQXBCO0FBQ0Q7QUFDRjtBQUNGLEdBaEVzQjtBQWtFdkJHLGdCQUFjLEVBQUUsVUFBU0gsUUFBVCxFQUFtQjtBQUNqQyxRQUFJRSxVQUFVLEdBQUdQLEtBQUssQ0FBQ0MsSUFBTixDQUFXSSxRQUFRLENBQUNFLFVBQXBCLENBQWpCO0FBRUEsU0FBS2xDLFNBQUwsQ0FBZXFDLE9BQWYsQ0FBdUIsQ0FBQztBQUFDMUIsYUFBRDtBQUFVUSxhQUFWO0FBQW1CQyxhQUFuQjtBQUE0QlAsZ0JBQTVCO0FBQXdDUTtBQUF4QyxLQUFELEVBQWdEQyxRQUFoRCxLQUE2RDtBQUVsRlUsY0FBUSxDQUFDRSxVQUFULENBQW9CRyxPQUFwQixDQUE2QkMsRUFBRCxJQUFRO0FBQ2xDLFlBQUksQ0FBQ0EsRUFBRSxDQUFDQyxPQUFSLEVBQWlCOztBQUVqQixZQUFJcEIsT0FBTyxJQUFJLEVBQUVtQixFQUFFLENBQUNwRCxPQUFILENBQVdpQyxPQUFYLEtBQXVCbUIsRUFBRSxDQUFDRSxhQUFILENBQWlCckIsT0FBakIsQ0FBekIsQ0FBZixFQUFvRTtBQUNsRTtBQUNEOztBQUNELFlBQUlDLE9BQU8sS0FBS2tCLEVBQUUsQ0FBQ3BELE9BQUgsQ0FBV2tDLE9BQVgsS0FBdUJrQixFQUFFLENBQUNFLGFBQUgsQ0FBaUJwQixPQUFqQixDQUE1QixDQUFYLEVBQW1FO0FBQ2pFO0FBQ0Q7O0FBRUQsWUFBSWtCLEVBQUUsQ0FBQ0csT0FBUCxFQUFnQjtBQUVoQm5CLGdCQUFRLENBQUNvQixLQUFULENBQWUsSUFBZixFQUFxQixDQUFDO0FBQUNULGNBQUksRUFBRUQsUUFBUSxDQUFDQyxJQUFoQjtBQUFzQlUsZ0JBQU0sRUFBRUw7QUFBOUIsU0FBRCxDQUFyQjtBQUNELE9BYkQ7QUFjRCxLQWhCRDtBQWtCQUosY0FBVSxDQUFDVSxHQUFYLENBQWVOLEVBQUUsSUFBSUEsRUFBRSxDQUFDRyxPQUFILEdBQWEsSUFBbEM7QUFDRCxHQXhGc0I7QUEwRnZCTCxnQkFBYyxFQUFFLFVBQVNKLFFBQVQsRUFBbUI7QUFDakMsU0FBSyxJQUFJLENBQUNYLElBQUQsRUFBTztBQUFFRixhQUFGO0FBQVdDO0FBQVgsS0FBUCxDQUFULElBQXlDLEtBQUtoQixVQUE5QyxFQUEwRDtBQUN4RCxVQUFJZSxPQUFPLElBQUksQ0FBQ2EsUUFBUSxDQUFDVyxNQUFULENBQWdCekQsT0FBaEIsQ0FBd0JpQyxPQUF4QixDQUFoQixFQUFrRDtBQUNsRCxVQUFJQyxPQUFPLElBQUlZLFFBQVEsQ0FBQ1csTUFBVCxDQUFnQnpELE9BQWhCLENBQXdCa0MsT0FBeEIsQ0FBZixFQUFpRDtBQUNsRDs7QUFDRCxTQUFLbEIsU0FBTCxDQUFlbUMsT0FBZixDQUF1QixDQUFDO0FBQUMxQixhQUFEO0FBQVVRLGFBQVY7QUFBbUJDLGFBQW5CO0FBQTRCUCxnQkFBNUI7QUFBd0NRO0FBQXhDLEtBQUQsRUFBZ0RDLFFBQWhELEtBQTZEO0FBQ2xGLFVBQUlULFVBQVUsSUFBSW1CLFFBQVEsQ0FBQ2EsYUFBdkIsSUFBd0MsQ0FBQ2hDLFVBQVUsQ0FBQ2lDLFFBQVgsQ0FBb0JkLFFBQVEsQ0FBQ2EsYUFBN0IsQ0FBN0MsRUFBMEY7QUFDeEY7QUFDRDs7QUFDRCxVQUFJMUIsT0FBTyxJQUFJLENBQUNhLFFBQVEsQ0FBQ1csTUFBVCxDQUFnQnpELE9BQWhCLENBQXdCaUMsT0FBeEIsQ0FBaEIsRUFBa0Q7QUFDbEQsVUFBSUMsT0FBTyxJQUFJWSxRQUFRLENBQUNXLE1BQVQsQ0FBZ0J6RCxPQUFoQixDQUF3QmtDLE9BQXhCLENBQWYsRUFBaUQ7O0FBRWpELFVBQUlZLFFBQVEsQ0FBQ2EsYUFBYixFQUE0QjtBQUMxQixZQUFJRSxRQUFRLEdBQUdmLFFBQVEsQ0FBQ1csTUFBVCxDQUFnQkssWUFBaEIsQ0FBNkJoQixRQUFRLENBQUNhLGFBQXRDLENBQWY7O0FBQ0EsWUFBSUUsUUFBUSxJQUFJZixRQUFRLENBQUNpQixRQUF6QixFQUFtQztBQUNqQzNCLGtCQUFRLENBQUNvQixLQUFULENBQWUsSUFBZixFQUFxQixDQUFDVixRQUFELENBQXJCO0FBQ0Q7QUFDRjtBQUVGLEtBZEQ7QUFlRCxHQTlHc0I7QUFnSHZCa0IsZ0JBQWMsRUFBRSxVQUFTQyxPQUFULEVBQWtCbEIsSUFBbEIsRUFBd0I7QUFDeEM7QUFDQUEsUUFBSSxHQUFHQSxJQUFJLElBQUksRUFBZjtBQUNBLFFBQUltQixHQUFHLEdBQUcsb0JBQW9CbkIsSUFBOUI7QUFDQWtCLFdBQU8sQ0FBQ0MsR0FBRCxDQUFQLEdBQWUsSUFBZjtBQUNBLEdBckh1QjtBQXVIeEJDLGdCQUFjLEVBQUUsVUFBU0YsT0FBVCxFQUFrQmxCLElBQWxCLEVBQXdCO0FBQ3ZDQSxRQUFJLEdBQUdBLElBQUksSUFBSSxFQUFmO0FBQ0EsUUFBSW1CLEdBQUcsR0FBRyxvQkFBb0JuQixJQUE5Qjs7QUFDQSxRQUFJLENBQUNrQixPQUFPLENBQUNDLEdBQUQsQ0FBWixFQUFtQjtBQUNsQixhQUFPLEtBQVA7QUFDQSxLQUZELE1BRU87QUFDTixhQUFPLElBQVA7QUFDQTtBQUNEO0FBL0h1QixDQUF6Qjs7QUFrSUFyRCxnQkFBZ0IsQ0FBQ00sTUFBakI7O0FBRUF4QixNQUFNLENBQUNrQixnQkFBUCxHQUEwQkEsZ0JBQTFCO2VBRWVBLGdCIiwiZmlsZSI6Ii4uL0NvQ3JlYXRlLWNvbXBvbmVudHMvQ29DcmVhdGUtb2JzZXJ2ZXIvc3JjL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsICgpID0+IHtcblxuLypcbkNvQ3JlYXRlLm9ic2VydmVyLmluaXQoeyBcblx0bmFtZTogJ0NvQ3JlYXRlRmV0Y2hJbml0JywgLy8gbm8gdXNhZ2UsIGp1c3QgdG8gcHJvdmlkZSBmb3IgY29uc29sZSBkZWJ1Z2dpbmcgXG5cdG9ic2VydmU6IFsnc3VidHJlZScsICdjaGlsZExpc3QnLCdhdHRyaWJ1dGVzJ10sIC8vIHRoZSBzYW1lIHBhcmFtZXRlcnMgb2Ygb3B0aW9ucyBpbiAjaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL011dGF0aW9uT2JzZXJ2ZXIvb2JzZXJ2ZVxuXHRhdHRyaWJ1dGVzOiBbJ2RhdGEtZmV0Y2hfY29sbGVjdGlvbiddLCAvLyBpdCBkb2Vzbid0IGNvdW50IGFkZGVkIG5vZGVzIG9yIHJlbW92ZSBub2Rlc1xuXHRpbmNsdWRlOiBcIi5jbGFzc25hbWVcIiwgLy8gYSBzZWxlY3RvciB0byBzZWxlY3Qgb25seSBlbGVtZW50cyB0aGF0IG1hdGNoZXNcblx0ZXhjbHVkZTogXCIuY2xhc3NuYW1lXCIsIC8vIGEgc2VsZWN0b3IgdG8gZXhjbHVkZSBlbGVtZW50cyBmcm9tIHByb2Nlc3Npbmdcblx0Y2FsbGJhY2s6IGZ1bmN0aW9uKG11dGF0aW9uKSB7IC8vIGEgZnVuY3Rpb24gd2hpY2ggZ2V0cyBhIG11dGF0aW9uIG9iamVjdCBhY2NvcmRpbmcgdG8gI2h0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NdXRhdGlvblJlY29yZFxuXHRcdENvQ3JlYXRlRmV0Y2guaW5pdEVsZW1lbnQobXV0YXRpb24udGFyZ2V0KVxuXHR9XG59KVxuKi9cblxuXG4vKipcbiAqIGRlc2NyaXB0aW9uXG4gKiBcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbmFtZV0gLSBhbiBvcHRpb25hbCBuYW1lIHRvIHByb3ZpZGUgZm9yIGRlYnVnZ2luZyBjb25zb2xlXG4gKiBAcGFyYW0ge0FycmF5fSBvYnNlcnZlIC0gYSBsaXN0IG9mIG11dGF0aW9uIHR5cGUgdG8gYmUgb2JzZXJ2ZXJkLCBhIG1peCBvZiBwb3NzaWJsZSBgYXR0cmlidXRlc2AsIGBjaGlsZExpc3RgIG9yIGBzdWJ0cmVlYFxuICogLi4uIGFuZCBvdGhlciBwYXJhbXMgY2FuIGJlIGhlcmUgXG4gKiBcbiAqIEByZXR1cm4gbnVsbFxuICovXG5cbndpbmRvdy5jb3VudGVyID0gMDtcbndpbmRvdy5jb3VudGVyMiA9IDA7XG5pZiAoIUVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMpIHtcbiAgRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyA9XG4gICAgRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgRWxlbWVudC5wcm90b3R5cGUubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICBFbGVtZW50LnByb3RvdHlwZS5vTWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgRWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgZnVuY3Rpb24ocykge1xuICAgICAgdmFyIG1hdGNoZXMgPSAodGhpcy5kb2N1bWVudCB8fCB0aGlzLm93bmVyRG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3JBbGwocyksXG4gICAgICAgIGkgPSBtYXRjaGVzLmxlbmd0aDtcbiAgICAgIHdoaWxlICgtLWkgPj0gMCAmJiBtYXRjaGVzLml0ZW0oaSkgIT09IHRoaXMpIHt9XG4gICAgICByZXR1cm4gaSA+IC0xO1xuICAgIH07XG59XG5cbmNvbnN0IENvQ3JlYXRlT2JzZXJ2ZXIgPSB7XG4gIGluaXRUYXNrczogbmV3IE1hcCgpLFxuICBhdHRyVGFza3M6IG5ldyBNYXAoKSxcbiAgcnVsZXM6IG5ldyBNYXAoKSxcbiAgcnVsZXNBcnJheTogW10sXG5cbiAgX19pbml0OiBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKChtdXRhdGlvbnNMaXN0LCBvYnNlcnZlcikgPT4gc2VsZi5fX2NhbGxiYWNrKG11dGF0aW9uc0xpc3QsIG9ic2VydmVyKSk7XG4gICAgXG4gICAgLy8gc2V0VGltZW91dCgoKT0+e1xuICAgIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQuYm9keSwgXG4gICAgICB7XG4gICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICAgICAgY2hhcmFjdGVyRGF0YTogZmFsc2UsXG4gICAgICAgIGF0dHJpYnV0ZU9sZFZhbHVlOiB0cnVlLFxuICAgICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICAgICAgfVxuICAgICk7XG4gIH0sXG4gIFxuICAvLyBpbml0OiBmdW5jdGlvbihkYXRhKSB7XG4gIC8vICAgdGhpcy5hZGQoZGF0YSk7XG4gIC8vIH0sXG4gIFxuICBpbml0OiBmdW5jdGlvbih7IG9ic2VydmUsIGluY2x1ZGUsIGV4Y2x1ZGUsIGF0dHJpYnV0ZXMsIG5hbWUsIGNhbGxiYWNrIH0pIHtcbiAgICBpZiAob2JzZXJ2ZS5zb21lKHggPT4geCA9PSBcImNoaWxkTGlzdFwiKSkge1xuICAgICAgdGhpcy5pbml0VGFza3Muc2V0KGNhbGxiYWNrLCB7IG9ic2VydmUsIGluY2x1ZGUsIGV4Y2x1ZGUsIGF0dHJpYnV0ZXMsIG5hbWUgfSk7XG4gICAgfVxuICAgIFxuICAgIGlmIChvYnNlcnZlLnNvbWUoeCA9PiAgeCA9PSBcImF0dHJpYnV0ZXNcIikpIHtcbiAgICAgIHRoaXMuYXR0clRhc2tzLnNldChjYWxsYmFjaywgeyBvYnNlcnZlLCBpbmNsdWRlLCBleGNsdWRlLCBhdHRyaWJ1dGVzLCBuYW1lIH0pO1xuICAgIH1cbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbih7IGluY2x1ZGUsIGV4Y2x1ZGUsIG5hbWUgfSkge1xuICAgIHRoaXMucnVsZXMuc2V0KG5hbWUsIHtpbmNsdWRlLCBleGNsdWRlfSk7XG4gICAgdGhpcy5ydWxlc0FycmF5ID0gQXJyYXkuZnJvbSh0aGlzLnJ1bGVzKTtcbiAgfSxcbiAgXG4gIGFkZFJ1bGU6IGZ1bmN0aW9uKHsgaW5jbHVkZSwgZXhjbHVkZSwgbmFtZSB9KSB7XG4gICAgdGhpcy5ydWxlcy5zZXQobmFtZSwge2luY2x1ZGUsIGV4Y2x1ZGV9KTtcbiAgICB0aGlzLnJ1bGVzQXJyYXkgPSBBcnJheS5mcm9tKHRoaXMucnVsZXMpO1xuICB9LFxuICBcbiAgcmVtb3ZlUnVsZTogZnVuY3Rpb24gKHtuYW1lfSkge1xuICAgIHRoaXMucnVsZXMuZGVsZXRlKG5hbWUpO1xuICAgIHRoaXMucnVsZXNBcnJheSA9IEFycmF5LmZyb20odGhpcy5ydWxlcyk7XG4gIH0sXG4gIFxuICBfX2NhbGxiYWNrOiBmdW5jdGlvbihtdXRhdGlvbnNMaXN0LCBvYnNlcnZlcikge1xuICAgIC8vIGNvbnNvbGUubG9nKHRoaXMpXG4gICAgZm9yIChsZXQgbXV0YXRpb24gb2YgbXV0YXRpb25zTGlzdCkge1xuICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT0gXCJjaGlsZExpc3RcIiAmJiBtdXRhdGlvbi5hZGRlZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8uIHJ1biBpbml0IGZ1bmN0aW9uc1xuICAgICAgICB0aGlzLl9faW5pdENhbGxiYWNrKG11dGF0aW9uKSAgICBcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT0gXCJhdHRyaWJ1dGVzXCIpIHtcbiAgICAgICAgLy8uIHJ1biBhdHRyaWJ1dGVzIGZ1bmN0aW9uc1xuICAgICAgICB0aGlzLl9fYXR0ckNhbGxiYWNrKG11dGF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFxuICBfX2luaXRDYWxsYmFjazogZnVuY3Rpb24obXV0YXRpb24pIHtcbiAgICBsZXQgYWRkZWROb2RlcyA9IEFycmF5LmZyb20obXV0YXRpb24uYWRkZWROb2Rlcyk7XG4gICAgXG4gICAgdGhpcy5pbml0VGFza3MuZm9yRWFjaCgoe29ic2VydmUsIGluY2x1ZGUsIGV4Y2x1ZGUsIGF0dHJpYnV0ZXMsIG5hbWV9LCBjYWxsYmFjaykgPT4ge1xuXG4gICAgICBtdXRhdGlvbi5hZGRlZE5vZGVzLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgIGlmICghZWwudGFnTmFtZSkgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgaWYgKGluY2x1ZGUgJiYgIShlbC5tYXRjaGVzKGluY2x1ZGUpIHx8IGVsLnF1ZXJ5U2VsZWN0b3IoaW5jbHVkZSkpKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH0gXG4gICAgICAgIGlmIChleGNsdWRlICYmIChlbC5tYXRjaGVzKGV4Y2x1ZGUpIHx8IGVsLnF1ZXJ5U2VsZWN0b3IoZXhjbHVkZSkpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoZWwuY3JlYXRlZCkgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgW3t0eXBlOiBtdXRhdGlvbi50eXBlLCB0YXJnZXQ6IGVsfV0pO1xuICAgICAgfSlcbiAgICB9KTtcbiAgICBcbiAgICBhZGRlZE5vZGVzLm1hcChlbCA9PiBlbC5jcmVhdGVkID0gdHJ1ZSk7XG4gIH0sXG4gIFxuICBfX2F0dHJDYWxsYmFjazogZnVuY3Rpb24obXV0YXRpb24pIHtcbiAgICBmb3IgKGxldCBbbmFtZSwgeyBpbmNsdWRlLCBleGNsdWRlIH1dIG9mIHRoaXMucnVsZXNBcnJheSkge1xuICAgICAgaWYgKGluY2x1ZGUgJiYgIW11dGF0aW9uLnRhcmdldC5tYXRjaGVzKGluY2x1ZGUpKSByZXR1cm47XG4gICAgICBpZiAoZXhjbHVkZSAmJiBtdXRhdGlvbi50YXJnZXQubWF0Y2hlcyhleGNsdWRlKSkgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmF0dHJUYXNrcy5mb3JFYWNoKCh7b2JzZXJ2ZSwgaW5jbHVkZSwgZXhjbHVkZSwgYXR0cmlidXRlcywgbmFtZX0sIGNhbGxiYWNrKSA9PiB7XG4gICAgICBpZiAoYXR0cmlidXRlcyAmJiBtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lICYmICFhdHRyaWJ1dGVzLmluY2x1ZGVzKG11dGF0aW9uLmF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpbmNsdWRlICYmICFtdXRhdGlvbi50YXJnZXQubWF0Y2hlcyhpbmNsdWRlKSkgcmV0dXJuO1xuICAgICAgaWYgKGV4Y2x1ZGUgJiYgbXV0YXRpb24udGFyZ2V0Lm1hdGNoZXMoZXhjbHVkZSkpIHJldHVybjtcblxuICAgICAgaWYgKG11dGF0aW9uLmF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgbGV0IG5ld1ZhbHVlID0gbXV0YXRpb24udGFyZ2V0LmdldEF0dHJpYnV0ZShtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgaWYgKG5ld1ZhbHVlICE9IG11dGF0aW9uLm9sZFZhbHVlKSB7XG4gICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgW211dGF0aW9uXSk7XG4gICAgICAgIH1cbiAgICAgIH0gICAgICBcbiAgICAgIFxuICAgIH0pXG4gIH0sXG4gIFxuICBzZXRJbml0aWFsaXplZDogZnVuY3Rpb24oZWxlbWVudCwgdHlwZSkge1xuXHRcdC8vIGVsZW1lbnQuc2V0QXR0cmlidXRlKGBpbml0aWFsaXplZF8ke3R5cGV9YCwgXCJ0cnVlXCIpO1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiXCI7XG5cdFx0bGV0IGtleSA9IFwiY29faW5pdGlhbGl6ZWRfXCIgKyB0eXBlO1xuXHRcdGVsZW1lbnRba2V5XSA9IHRydWU7XG5cdH0sXG5cdFxuXHRnZXRJbml0aWFsaXplZDogZnVuY3Rpb24oZWxlbWVudCwgdHlwZSkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiXCI7XG5cdFx0bGV0IGtleSA9IFwiY29faW5pdGlhbGl6ZWRfXCIgKyB0eXBlO1xuXHRcdGlmICghZWxlbWVudFtrZXldKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fVxufVxuXG5Db0NyZWF0ZU9ic2VydmVyLl9faW5pdCgpO1xuXG53aW5kb3cuQ29DcmVhdGVPYnNlcnZlciA9IENvQ3JlYXRlT2JzZXJ2ZXI7XG5cbmV4cG9ydCBkZWZhdWx0IENvQ3JlYXRlT2JzZXJ2ZXI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../CoCreate-components/CoCreate-observer/src/index.js\n");

/***/ })

/******/ })["default"];
});